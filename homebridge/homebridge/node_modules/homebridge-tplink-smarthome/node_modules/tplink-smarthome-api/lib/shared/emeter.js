"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _realtime;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRealtime = void 0;
const utils_1 = require("../utils");
function isRealtime(candidate) {
    return utils_1.isObjectLike(candidate);
}
exports.isRealtime = isRealtime;
class Emeter {
    constructor(device, apiModuleName, childId = undefined) {
        this.device = device;
        this.apiModuleName = apiModuleName;
        this.childId = childId;
        _realtime.set(this, {});
    }
    /**
     * Returns cached results from last retrieval of `emeter.get_realtime`.
     * @returns {Object}
     */
    get realtime() {
        return __classPrivateFieldGet(this, _realtime);
    }
    /**
     * @private
     */
    setRealtime(realtime) {
        const normRealtime = { ...realtime }; // will coerce null/undefined to {}
        const normalize = (key1, key2, multiplier) => {
            const r = normRealtime;
            if (typeof r[key1] === 'number' && r[key2] === undefined) {
                r[key2] = Math.floor(r[key1] * multiplier);
            }
            else if (r[key1] == null && typeof r[key2] === 'number') {
                r[key1] = r[key2] / multiplier;
            }
        };
        if (realtime != null) {
            normalize('current', 'current_ma', 1000);
            normalize('power', 'power_mw', 1000);
            normalize('total', 'total_wh', 1000);
            normalize('voltage', 'voltage_mv', 1000);
        }
        __classPrivateFieldSet(this, _realtime, normRealtime);
        this.device.emit('emeter-realtime-update', __classPrivateFieldGet(this, _realtime));
    }
    /**
     * Gets device's current energy stats.
     *
     * Requests `emeter.get_realtime`. Older devices return `current`, `voltage`, etc,
     * while newer devices return `current_ma`, `voltage_mv` etc
     * This will return a normalized response including both old and new style properties for backwards compatibility.
     * Supports childId.
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getRealtime(sendOptions) {
        this.setRealtime(utils_1.extractResponse(await this.device.sendCommand({
            [this.apiModuleName]: { get_realtime: {} },
        }, this.childId, sendOptions), '', (c) => isRealtime(c) && utils_1.hasErrCode(c)));
        return this.realtime;
    }
    /**
     * Get Daily Emeter Statistics.
     *
     * Sends `emeter.get_daystat` command. Supports childId.
     * @param   year
     * @param   month
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getDayStats(year, month, sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { get_daystat: { year, month } },
        }, this.childId, sendOptions);
    }
    /**
     * Get Monthly Emeter Statistics.
     *
     * Sends `emeter.get_monthstat` command. Supports childId.
     * @param   year
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async getMonthStats(year, sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { get_monthstat: { year } },
        }, this.childId, sendOptions);
    }
    /**
     * Erase Emeter Statistics.
     *
     * Sends `emeter.erase_runtime_stat` command. Supports childId.
     * @param   sendOptions
     * @returns parsed JSON response
     * @throws {@link ResponseError}
     */
    async eraseStats(sendOptions) {
        return this.device.sendCommand({
            [this.apiModuleName]: { erase_emeter_stat: {} },
        }, this.childId, sendOptions);
    }
}
exports.default = Emeter;
_realtime = new WeakMap();
module.exports = Emeter;
//# sourceMappingURL=emeter.js.map