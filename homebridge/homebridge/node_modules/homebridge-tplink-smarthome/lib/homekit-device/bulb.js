"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __importDefault(require("."));
const utils_1 = require("../utils");
class HomeKitDeviceBulb extends _1.default {
    constructor(platform, tplinkDevice, category) {
        super(platform, tplinkDevice, category);
        this.tplinkDevice = tplinkDevice;
        this.category = category;
        this.desiredLightState = {};
        this.addBasicCharacteristics();
        if (tplinkDevice.supportsBrightness) {
            this.addBrightnessCharacteristics();
        }
        if (tplinkDevice.supportsColorTemperature) {
            this.addColorTemperatureCharacteristics();
        }
        if (tplinkDevice.supportsColor) {
            this.addColorCharacteristics();
        }
        if (platform.config.addCustomCharacteristics &&
            tplinkDevice.supportsEmeter) {
            this.addEnergyCharacteristics();
        }
        this.getLightState = utils_1.deferAndCombine((requestCount) => {
            this.log.debug(`executing deferred getLightState count: ${requestCount}`);
            return this.tplinkDevice.lighting.getLightState();
        }, platform.config.waitTimeUpdate);
        this.setLightState = utils_1.deferAndCombine((requestCount) => {
            this.log.debug(`executing deferred setLightState count: ${requestCount}`);
            if (Object.keys(this.desiredLightState).length === 0) {
                this.log.warn('setLightState called with empty desiredLightState');
                return Promise.resolve(true);
            }
            const ret = this.tplinkDevice.lighting.setLightState(this.desiredLightState);
            this.desiredLightState = {};
            return ret;
        }, platform.config.waitTimeUpdate, (value) => {
            this.desiredLightState = Object.assign(this.desiredLightState, value);
        });
        this.getRealtime = utils_1.deferAndCombine(() => {
            return this.tplinkDevice.emeter.getRealtime();
        }, platform.config.waitTimeUpdate);
    }
    addBasicCharacteristics() {
        this.addCharacteristic(this.platform.Characteristic.On, {
            getValue: async () => {
                this.getLightState().catch(this.logRejection.bind(this)); // this will eventually trigger update
                return this.tplinkDevice.lighting.lightState.on_off === 1; // immediately returned cached value
            },
            setValue: async (value) => {
                if (typeof value === 'boolean') {
                    await this.setLightState({ on_off: value ? 1 : 0 });
                    return;
                }
                this.log.warn('setValue: Invalid On:', value);
            },
        });
        this.tplinkDevice.on('lightstate-on', () => {
            this.fireCharacteristicUpdateCallback(this.platform.Characteristic.On, true);
        });
        this.tplinkDevice.on('lightstate-off', () => {
            this.fireCharacteristicUpdateCallback(this.platform.Characteristic.On, false);
        });
        this.tplinkDevice.on('lightstate-update', (lightState) => {
            if (lightState.on_off != null) {
                this.fireCharacteristicUpdateCallback(this.platform.Characteristic.On, lightState.on_off === 1);
            }
            if (lightState.brightness != null) {
                this.fireCharacteristicUpdateCallback(this.platform.Characteristic.Brightness, lightState.brightness);
            }
            if (lightState.color_temp != null && lightState.color_temp > 0) {
                this.fireCharacteristicUpdateCallback(this.platform.Characteristic.ColorTemperature, Math.round(utils_1.kelvinToMired(lightState.color_temp)));
                this.fireCharacteristicUpdateCallback(this.platform.Characteristic.Hue, 0);
                this.fireCharacteristicUpdateCallback(this.platform.Characteristic.Saturation, 0);
            }
            else {
                if (lightState.hue != null) {
                    this.fireCharacteristicUpdateCallback(this.platform.Characteristic.Hue, lightState.hue);
                }
                if (lightState.saturation != null) {
                    this.fireCharacteristicUpdateCallback(this.platform.Characteristic.Saturation, lightState.saturation);
                }
            }
        });
    }
    addBrightnessCharacteristics() {
        this.addCharacteristic(this.platform.Characteristic.Brightness, {
            getValue: async () => {
                var _a, _b, _c;
                this.getLightState().catch(this.logRejection.bind(this)); // this will eventually trigger update
                const ls = this.tplinkDevice.lighting.lightState;
                return (_c = (_a = ls.brightness) !== null && _a !== void 0 ? _a : (_b = ls.dft_on_state) === null || _b === void 0 ? void 0 : _b.brightness) !== null && _c !== void 0 ? _c : 0; // immediately returned cached value
            },
            setValue: async (value) => {
                if (typeof value === 'number') {
                    await this.setLightState({ brightness: value });
                    return;
                }
                this.log.warn('setValue: Invalid Brightness:', value);
            },
        });
    }
    addColorTemperatureCharacteristics() {
        const range = this.tplinkDevice.colorTemperatureRange;
        if (range == null) {
            this.log.error('Could not retrieve color temperature range');
            return;
        }
        const { min, max } = range;
        this.addCharacteristic(this.platform.Characteristic.ColorTemperature, {
            props: {
                minValue: Math.ceil(utils_1.kelvinToMired(max)),
                maxValue: Math.floor(utils_1.kelvinToMired(min)), // K and Mired are reversed
            },
            getValue: async () => {
                var _a;
                this.getLightState().catch(this.logRejection.bind(this)); // this will eventually trigger update
                const ls = this.tplinkDevice.lighting.lightState;
                // immediately returned cached value
                if (typeof ls.color_temp === 'number' && ls.color_temp > 0) {
                    return Math.round(utils_1.kelvinToMired(ls.color_temp));
                }
                if (typeof ((_a = ls.dft_on_state) === null || _a === void 0 ? void 0 : _a.color_temp) === 'number' &&
                    ls.dft_on_state.color_temp > 0) {
                    return Math.round(utils_1.kelvinToMired(ls.dft_on_state.color_temp));
                }
                if (!('color_temp' in ls)) {
                    return Math.floor(utils_1.kelvinToMired(min));
                }
                return Math.floor(utils_1.kelvinToMired(min));
            },
            setValue: async (value) => {
                if (typeof value === 'number') {
                    await this.setLightState({
                        color_temp: Math.round(utils_1.miredToKelvin(value)),
                    });
                    return;
                }
                this.log.warn('setValue: Invalid ColorTemperature:', value);
            },
        });
    }
    addColorCharacteristics() {
        this.addCharacteristic(this.platform.Characteristic.Hue, {
            getValue: async () => {
                var _a, _b, _c;
                this.getLightState().catch(this.logRejection.bind(this)); // this will eventually trigger update
                const ls = this.tplinkDevice.lighting.lightState;
                return (_c = (_a = ls.hue) !== null && _a !== void 0 ? _a : (_b = ls.dft_on_state) === null || _b === void 0 ? void 0 : _b.hue) !== null && _c !== void 0 ? _c : 0; // immediately returned cached value
            },
            setValue: async (value) => {
                if (typeof value === 'number') {
                    await this.setLightState({ hue: value, color_temp: 0 });
                    return;
                }
                this.log.warn('setValue: Invalid Hue:', value);
            },
        });
        this.addCharacteristic(this.platform.Characteristic.Saturation, {
            getValue: async () => {
                var _a, _b, _c;
                this.getLightState().catch(this.logRejection.bind(this)); // this will eventually trigger update
                const ls = this.tplinkDevice.lighting.lightState;
                return (_c = (_a = ls.saturation) !== null && _a !== void 0 ? _a : (_b = ls.dft_on_state) === null || _b === void 0 ? void 0 : _b.saturation) !== null && _c !== void 0 ? _c : 0; // immediately returned cached value
            },
            setValue: async (value) => {
                if (typeof value === 'number') {
                    await this.setLightState({ saturation: value, color_temp: 0 });
                    return;
                }
                this.log.warn('setValue: Invalid Saturation:', value);
            },
        });
    }
    addEnergyCharacteristics() {
        this.addCharacteristic(this.platform.customCharacteristics.Watts, {
            getValue: async () => {
                await this.getRealtime(); // this will eventually trigger update
                // immediately returned cached value
                const emeterRealtime = this.tplinkDevice.emeter.realtime;
                if (typeof emeterRealtime.power === 'number') {
                    return emeterRealtime.power;
                }
                this.log.warn(`getValue: Invalid Watts:`, emeterRealtime.power);
                return null;
            },
        });
        this.tplinkDevice.on('emeter-realtime-update', (emeterRealtime) => {
            this.fireCharacteristicUpdateCallback(this.platform.customCharacteristics.Watts, emeterRealtime.power);
        });
    }
    identify() {
        this.log.debug(`identify`);
        (async () => {
            try {
                const origLs = await this.getLightState();
                for (let i = 0; i < 3; i += 1) {
                    /* eslint-disable no-await-in-loop */
                    await this.setLightState({ on_off: 1, brightness: 100 });
                    await utils_1.delay(500);
                    await this.setLightState({ on_off: 1, brightness: 10 });
                    await utils_1.delay(500);
                    /* eslint-enable no-await-in-loop */
                }
                this.setLightState(origLs);
            }
            catch (err) {
                this.log.error(`identify error`);
                this.log.error(err);
            }
            this.log.debug(`identify complete`);
        })();
    }
}
exports.default = HomeKitDeviceBulb;
//# sourceMappingURL=bulb.js.map