#!/usr/bin/env node
"use strict";
/* eslint-disable no-console */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_castarray_1 = __importDefault(require("lodash.castarray"));
const commander_1 = __importDefault(require("commander"));
const tplinkCrypto = __importStar(require("tplink-smarthome-crypto"));
const util_1 = __importDefault(require("util"));
const _1 = require(".");
let logLevel;
function outputError(err) {
    if (err instanceof _1.ResponseError) {
        console.log('Response Error:');
        console.log(err.response);
    }
    else {
        console.error('Error:');
        console.error(err);
    }
}
function getClient() {
    const defaultSendOptions = {};
    const options = commander_1.default.opts();
    if (options.udp)
        defaultSendOptions.transport = 'udp';
    if (options.timeout)
        defaultSendOptions.timeout = options.timeout;
    return new _1.Client({ logLevel, defaultSendOptions });
}
function search(sysInfo, breakoutChildren, discoveryTimeout, broadcast, params) {
    try {
        console.log('Searching...');
        const commandParams = {
            discoveryInterval: 2000,
            discoveryTimeout,
            breakoutChildren,
            broadcast,
            ...params,
        };
        console.log(`startDiscovery(${util_1.default.inspect(commandParams)})`);
        getClient()
            .startDiscovery(commandParams)
            .on('device-new', (device) => {
            console.log(`${device.model} ${device.deviceType} ${device.type} ${device.host} ${device.port} ${device.macNormalized} ${device.deviceId} ${device.alias}`);
            if (sysInfo) {
                console.dir(device.sysInfo, {
                    colors: commander_1.default.opts().color === 'on',
                    depth: 10,
                });
            }
        });
    }
    catch (err) {
        outputError(err);
    }
}
async function send(host, port, payload) {
    try {
        const client = getClient();
        console.log(`Sending to ${host}:${port || ''} via ${client.defaultSendOptions.transport}...`);
        const data = await client.send(payload, host, port);
        console.log('response:');
        console.dir(data, { colors: commander_1.default.opts().color === 'on', depth: 10 });
    }
    catch (err) {
        outputError(err);
    }
}
async function sendCommand(host, port, childId, payload) {
    try {
        const client = getClient();
        console.log(`Sending to ${host}:${port || ''} ${childId ? `childId: ${childId}` : ''} via ${client.defaultSendOptions.transport}...`);
        const device = await client.getDevice({ host, port, childId });
        const results = await device.sendCommand(payload);
        console.log('response:');
        console.dir(results, { colors: commander_1.default.opts().color === 'on', depth: 10 });
    }
    catch (err) {
        outputError(err);
    }
}
async function sendCommandDynamic(host, port, 
// eslint-disable-next-line @typescript-eslint/ban-types
command, commandParams = [], childId) {
    try {
        const client = getClient();
        console.log(`Sending ${command} command to ${host}:${port || ''} ${childId ? `childId: ${childId}` : ''} via ${client.defaultSendOptions.transport}...`);
        const device = await client.getDevice({ host, port, childId });
        // @ts-ignore: ignoring for now
        const results = await device[command](...commandParams);
        console.log('response:');
        console.dir(results, { colors: commander_1.default.opts().color === 'on', depth: 10 });
    }
    catch (err) {
        outputError(err);
    }
}
async function details(host, port) {
    try {
        console.log(`Getting details from ${host}:${port || ''}...`);
        const device = await getClient().getDevice({ host, port });
        console.dir({
            alias: device.alias,
            deviceId: device.deviceId,
            description: device.description,
            model: device.model,
            deviceType: device.deviceType,
            type: device.type,
            softwareVersion: device.softwareVersion,
            hardwareVersion: device.hardwareVersion,
            mac: device.mac,
        }, { colors: commander_1.default.opts().color === 'on', depth: 10 });
    }
    catch (err) {
        outputError(err);
    }
}
async function blink(host, port, times, rate) {
    console.log(`Sending blink commands to ${host}:${port || ''}...`);
    getClient()
        .getDevice({ host, port })
        .then((device) => {
        // @ts-ignore: ignoring for now, need to implement blink on bulb
        return device.blink(times, rate).then(() => {
            console.log('Blinking complete');
        });
    })
        .catch((reason) => {
        outputError(reason);
    });
}
async function getScanInfo(host, port, refresh, timeoutInSeconds) {
    console.log(`Sending getScanInfo command to ${host}:${port || ''}...`);
    getClient()
        .getDevice({ host, port })
        .then((device) => {
        // @ts-ignore: ignoring for now, need to implement blink on bulb
        return device.netif
            .getScanInfo(refresh, timeoutInSeconds)
            .then((value) => {
            console.dir(value);
        });
    })
        .catch((reason) => {
        outputError(reason);
    });
}
function toInt(s) {
    return parseInt(s, 10);
}
function toBoolean(s) {
    return s === 'true' || s === '1';
}
function setParamTypes(params, commandSetup) {
    if (params &&
        params.length > 0 &&
        commandSetup.params &&
        commandSetup.params.length > 0) {
        const sParams = commandSetup.params;
        return lodash_castarray_1.default(params).map((el, i) => {
            var _a;
            switch ((_a = sParams[i]) === null || _a === void 0 ? void 0 : _a.type) {
                case 'number':
                    return +el;
                case 'boolean':
                    return toBoolean(el);
                default:
                    return el;
            }
        });
    }
    return params;
}
commander_1.default
    .option('-D, --debug', 'turn on debug level logging', () => {
    logLevel = 'debug';
})
    .option('-t, --timeout <ms>', 'timeout (ms)', toInt, 10000)
    .option('-u, --udp', 'send via UDP')
    .option('-c, --color [on]', 'output will be styled with ANSI color codes', 'on');
commander_1.default
    .command('search [params]')
    .description('Search for devices')
    .option('--broadcast <address>', 'broadcast address', '255.255.255.255')
    .option('-s, --sysinfo', 'output sysInfo')
    .option('-b, --breakout-children', 'output children (multi-outlet plugs)', true)
    .action((params, options) => {
    let paramsObj;
    if (params) {
        console.dir(params);
        paramsObj = JSON.parse(params);
    }
    search(options.sysinfo, options.breakoutChildren || false, commander_1.default.opts().timeout, options.broadcast, paramsObj);
});
commander_1.default
    .command('send <host> <payload>')
    .description('Send payload to device (using Client.send)')
    .action((host, payload) => {
    const [hostOnly, port] = host.split(':');
    send(hostOnly, port, payload);
});
commander_1.default
    .command('sendCommand <host> <payload>')
    .description('Send payload to device (using Device#sendCommand)')
    .option('--childId [childId]', 'childId')
    .action((host, payload, options) => {
    const [hostOnly, port] = host.split(':');
    sendCommand(hostOnly, port, options.childId, payload);
});
commander_1.default.command('details <host>').action((host) => {
    const [hostOnly, port] = host.split(':');
    details(hostOnly, port);
});
commander_1.default
    .command('blink <host> [times] [rate]')
    .action((host, times = 5, rate = 500) => {
    const [hostOnly, port] = host.split(':');
    blink(hostOnly, port, times, rate);
});
commander_1.default
    .command('getScanInfo <host> [refresh] [timeoutInSeconds]')
    .action((host, refresh = true, timeoutInSeconds = 5) => {
    const [hostOnly, port] = host.split(':');
    getScanInfo(hostOnly, port, refresh !== undefined ? toBoolean(refresh) : undefined, timeoutInSeconds);
});
const commandSetup = [
    { name: 'getSysInfo', supportsChildId: true },
    { name: 'getInfo', supportsChildId: true },
    { name: 'setAlias', supportsChildId: true },
    { name: 'getModel', supportsChildId: true },
    {
        name: 'setPowerState',
        params: [{ name: 'state', type: 'boolean' }],
        supportsChildId: true,
    },
    {
        name: 'setLocation',
        params: [
            { name: 'latitude', type: 'number' },
            { name: 'longitude', type: 'number' },
        ],
    },
    { name: 'reboot', params: [{ name: 'delay', type: 'number' }] },
    { name: 'reset', params: [{ name: 'delay', type: 'number' }] },
];
for (const command of commandSetup) {
    const paramsString = command.params
        ? command.params.map((p) => `[${p.name}]`).join(' ')
        : '';
    const cmd = commander_1.default
        .command(`${command.name} <host> ${paramsString}`)
        .description(`Send ${command.name} to device (using Device#${command.name})`)
        .option('-t, --timeout [timeout]', 'timeout (ms)', toInt, 10000);
    if (command.supportsChildId) {
        cmd.option('-c, --childId [childId]', 'childId');
    }
    cmd.action((host, paramsInput, optionsInput) => {
        const [hostOnly, port] = host.split(':');
        // paramsInput will be options when command has not params
        let options;
        let params;
        if (optionsInput === undefined) {
            options = paramsInput;
            params = undefined;
        }
        else {
            options = optionsInput;
            params = paramsInput;
        }
        const commandParams = setParamTypes(params, command);
        sendCommandDynamic(hostOnly, port, command.name, commandParams, options.childId);
    });
}
commander_1.default
    .command('encrypt <outputEncoding> <input> [firstKey=0xAB]')
    .action((outputEncoding, input, firstKey = 0xab) => {
    const outputBuf = tplinkCrypto.encrypt(input, firstKey);
    console.log(outputBuf.toString(outputEncoding));
});
commander_1.default
    .command('encryptWithHeader <outputEncoding> <input> [firstKey=0xAB]')
    .action((outputEncoding, input, firstKey = 0xab) => {
    const outputBuf = tplinkCrypto.encryptWithHeader(input, firstKey);
    console.log(outputBuf.toString(outputEncoding));
});
commander_1.default
    .command('decrypt <inputEncoding> <input> [firstKey=0xAB]')
    .action((inputEncoding, input, firstKey = 0xab) => {
    const inputBuf = Buffer.from(input, inputEncoding);
    const outputBuf = tplinkCrypto.decrypt(inputBuf, firstKey);
    console.log(outputBuf.toString());
});
commander_1.default
    .command('decryptWithHeader <inputEncoding> <input> [firstKey=0xAB]')
    .action((inputEncoding, input, firstKey = 0xab) => {
    const inputBuf = Buffer.from(input, inputEncoding);
    const outputBuf = tplinkCrypto.decryptWithHeader(inputBuf, firstKey);
    console.log(outputBuf.toString());
});
commander_1.default.parse(process.argv);
if (!process.argv.slice(2).length) {
    commander_1.default.outputHelp();
}
//# sourceMappingURL=cli.js.map