"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const device_1 = __importStar(require("../device"));
const cloud_1 = __importDefault(require("../shared/cloud"));
const emeter_1 = __importDefault(require("../shared/emeter"));
const lighting_1 = __importDefault(require("./lighting"));
const schedule_1 = __importDefault(require("./schedule"));
const time_1 = __importDefault(require("../shared/time"));
/**
 * Bulb Device.
 *
 * @fires  Bulb#emeter-realtime-update
 * @fires  Bulb#lightstate-on
 * @fires  Bulb#lightstate-off
 * @fires  Bulb#lightstate-change
 * @fires  Bulb#lightstate-update
 */
class Bulb extends device_1.default {
    /**
     * Created by {@link Client} - Do not instantiate directly.
     *
     * See [Device constructor]{@link Device} for common options.
     * @see Device
     * @param options -
     */
    constructor(options) {
        super({
            client: options.client,
            _sysInfo: options.sysInfo,
            host: options.host,
            port: options.port,
            logger: options.logger,
            defaultSendOptions: options.defaultSendOptions,
        });
        /**
         * @internal
         */
        this.lastState = { inUse: false, powerOn: false };
        this.supportsEmeter = true;
        /**
         * @borrows Cloud#getInfo as Bulb.cloud#getInfo
         * @borrows Cloud#bind as Bulb.cloud#bind
         * @borrows Cloud#unbind as Bulb.cloud#unbind
         * @borrows Cloud#getFirmwareList as Bulb.cloud#getFirmwareList
         * @borrows Cloud#setServerUrl as Bulb.cloud#setServerUrl
         */
        this.cloud = new cloud_1.default(this, 'smartlife.iot.common.cloud');
        /**
         * @borrows Emeter#realtime as Bulb.emeter#realtime
         * @borrows Emeter#getRealtime as Bulb.emeter#getRealtime
         * @borrows Emeter#getDayStats as Bulb.emeter#getDayStats
         * @borrows Emeter#getMonthStats as Bulb.emeter#getMonthStats
         * @borrows Emeter#eraseStats as Bulb.emeter#eraseStats
         */
        this.emeter = new emeter_1.default(this, 'smartlife.iot.common.emeter');
        /**
         * @borrows Lighting#lightState as Bulb.lighting#lightState
         * @borrows Lighting#getLightState as Bulb.lighting#getLightState
         * @borrows Lighting#setLightState as Bulb.lighting#setLightState
         */
        this.lighting = new lighting_1.default(this, 'smartlife.iot.smartbulb.lightingservice');
        /**
         * @borrows Schedule#getNextAction as Bulb.schedule#getNextAction
         * @borrows Schedule#getRules as Bulb.schedule#getRules
         * @borrows Schedule#getRule as Bulb.schedule#getRule
         * @borrows BulbSchedule#addRule as Bulb.schedule#addRule
         * @borrows BulbSchedule#editRule as Bulb.schedule#editRule
         * @borrows Schedule#deleteAllRules as Bulb.schedule#deleteAllRules
         * @borrows Schedule#deleteRule as Bulb.schedule#deleteRule
         * @borrows Schedule#setOverallEnable as Bulb.schedule#setOverallEnable
         * @borrows Schedule#getDayStats as Bulb.schedule#getDayStats
         * @borrows Schedule#getMonthStats as Bulb.schedule#getMonthStats
         * @borrows Schedule#eraseStats as Bulb.schedule#eraseStats
         */
        this.schedule = new schedule_1.default(this, 'smartlife.iot.common.schedule');
        /**
         * @borrows Time#getTime as Bulb.time#getTime
         * @borrows Time#getTimezone as Bulb.time#getTimezone
         */
        this.time = new time_1.default(this, 'smartlife.iot.common.timesetting');
        this.lastState = Object.assign(this.lastState, {
            powerOn: null,
            inUse: null,
        });
        this.setSysInfo(options.sysInfo);
        this._sysInfo = options.sysInfo;
    }
    /**
     * Returns cached results from last retrieval of `system.sysinfo`.
     * @returns system.sysinfo
     */
    get sysInfo() {
        return this._sysInfo;
    }
    /**
     * @internal
     */
    setSysInfo(sysInfo) {
        super.setSysInfo(sysInfo);
        // TODO / XXX Verify that sysInfo.light_state can be set here to trigger events
        this.lighting.lightState = sysInfo.light_state;
    }
    setAliasProperty(alias) {
        this.sysInfo.alias = alias;
    }
    /**
     * Cached value of `sysinfo.[description|dev_name]`.
     */
    get description() {
        return this.sysInfo.description;
    }
    // eslint-disable-next-line class-methods-use-this
    get deviceType() {
        return 'bulb';
    }
    /**
     * Cached value of `sysinfo.is_dimmable === 1`
     * @returns Cached value of `sysinfo.is_dimmable === 1`
     */
    get supportsBrightness() {
        return this.sysInfo.is_dimmable === 1;
    }
    /**
     * Cached value of `sysinfo.is_color === 1`
     * @returns Cached value of `sysinfo.is_color === 1`
     */
    get supportsColor() {
        return this.sysInfo.is_color === 1;
    }
    /**
     * Cached value of `sysinfo.is_variable_color_temp === 1`
     * @returns Cached value of `sysinfo.is_variable_color_temp === 1`
     */
    get supportsColorTemperature() {
        return this.sysInfo.is_variable_color_temp === 1;
    }
    /**
     * Returns array with min and max supported color temperatures
     * @returns range in kelvin `{min,max}` or `null` if not supported
     */
    get colorTemperatureRange() {
        if (!this.supportsColorTemperature)
            return null;
        switch (true) {
            case /LB130/i.test(this.sysInfo.model):
                return { min: 2500, max: 9000 };
            default:
                return { min: 2700, max: 6500 };
        }
    }
    /**
     * Returns array with min and max supported color temperatures
     * @returns range in kelvin `{min,max}` or `null` if not supported
     *
     * @deprecated Renamed, use {@link Bulb.colorTemperatureRange}
     */
    get getColorTemperatureRange() {
        return this.colorTemperatureRange;
    }
    /**
     * Gets bulb's SysInfo.
     *
     * Requests `system.sysinfo` from device.
     * @returns parsed JSON response
     */
    async getSysInfo(sendOptions) {
        const response = await super.getSysInfo(sendOptions);
        if (!device_1.isBulbSysinfo(response)) {
            throw new Error(`Unexpected Response: ${response}`);
        }
        return this.sysInfo;
    }
    /**
     * Requests common Bulb status details in a single request.
     * - `system.get_sysinfo`
     * - `cloud.get_sysinfo`
     * - `emeter.get_realtime`
     * - `schedule.get_next_action`
     *
     * This command is likely to fail on some devices when using UDP transport.
     * This defaults to TCP transport unless overridden in sendOptions.
     *
     * @returns parsed JSON response
     */
    async getInfo(sendOptions) {
        // force TCP unless overridden here
        const sendOptionsForGetInfo = sendOptions == null ? {} : sendOptions;
        if (!('transport' in sendOptionsForGetInfo))
            sendOptionsForGetInfo.transport = 'tcp';
        // TODO switch to sendCommand, but need to handle error for devices that don't support emeter
        const response = await this.send(`{"${this.apiModules.emeter}":{"get_realtime":{}},"${this.apiModules.lightingservice}":{"get_light_state":{}},"${this.apiModules.schedule}":{"get_next_action":{}},"system":{"get_sysinfo":{}},"${this.apiModules.cloud}":{"get_info":{}}}`, sendOptionsForGetInfo);
        const data = JSON.parse(response);
        this.setSysInfo(data.system.get_sysinfo);
        this.cloud.info = data[this.apiModules.cloud].get_info;
        this.emeter.setRealtime(data[this.apiModules.emeter].get_realtime);
        this.schedule.nextAction = data[this.apiModules.schedule].get_next_action;
        this.lighting.lightState =
            data[this.apiModules.lightingservice].get_light_state;
        return {
            sysInfo: this.sysInfo,
            cloud: { info: this.cloud.info },
            emeter: { realtime: this.emeter.realtime },
            schedule: { nextAction: this.schedule.nextAction },
            lighting: { lightState: this.lighting.lightState },
        };
    }
    /**
     * Gets on/off state of Bulb.
     *
     * Requests `lightingservice.get_light_state` and returns true if `on_off === 1`.
     * @throws {@link ResponseError}
     */
    async getPowerState(sendOptions) {
        const lightState = await this.lighting.getLightState(sendOptions);
        return lightState.on_off === 1;
    }
    /**
     * Sets on/off state of Bulb.
     *
     * Sends `lightingservice.transition_light_state` command with on_off `value`.
     * @param  value - true: on, false: off
     * @throws {@link ResponseError}
     */
    async setPowerState(value, sendOptions) {
        return this.lighting.setLightState({ on_off: value ? 1 : 0 }, sendOptions);
    }
    /**
     * Toggles state of Bulb.
     *
     * Requests `lightingservice.get_light_state` sets the power state to the opposite of `on_off === 1` and returns the new power state.
     * @throws {@link ResponseError}
     */
    async togglePowerState(sendOptions) {
        const powerState = await this.getPowerState(sendOptions);
        await this.setPowerState(!powerState, sendOptions);
        return !powerState;
    }
}
exports.default = Bulb;
Bulb.apiModules = {
    system: 'smartlife.iot.common.system',
    cloud: 'smartlife.iot.common.cloud',
    schedule: 'smartlife.iot.common.schedule',
    timesetting: 'smartlife.iot.common.timesetting',
    emeter: 'smartlife.iot.common.emeter',
    netif: 'netif',
    lightingservice: 'smartlife.iot.smartbulb.lightingservice',
};
//# sourceMappingURL=index.js.map