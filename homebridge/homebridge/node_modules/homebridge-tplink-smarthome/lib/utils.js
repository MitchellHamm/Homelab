"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixLogger = exports.miredToKelvin = exports.lookupCharacteristicNameByUUID = exports.lookup = exports.kelvinToMired = exports.getOrAddCharacteristic = exports.delay = exports.deferAndCombine = exports.isObjectLike = void 0;
function isObjectLike(candidate) {
    return ((typeof candidate === 'object' && candidate !== null) ||
        typeof candidate === 'function');
}
exports.isObjectLike = isObjectLike;
/**
 * Creates a function that will "batch" calls that are within the `timeout`
 *
 * The first time the function that is created is called, it will wait the `timeout` for additional calls.
 * After the `timeout` expires the result of one execution of `fn` will be resolved to all calls during the `timeout`.
 *
 * If `runNowFn` is specified it will be run synchronously without a timeout. Useful for functions that are used to set rather than get.
 *
 * @param {() => Promise<T>} fn
 * @param {number} timeout (ms)
 * @param {(arg: U) => void} [runNowFn]
 * @returns {(arg?: U) => Promise<T>}
 */
function deferAndCombine(fn, timeout, runNowFn) {
    const requests = [];
    let isWaiting = false;
    return (arg) => {
        if (runNowFn !== undefined && arg !== undefined) {
            runNowFn(arg);
        }
        return new Promise((resolve, reject) => {
            requests.push({ resolve, reject });
            if (isWaiting)
                return;
            isWaiting = true;
            setTimeout(() => {
                isWaiting = false;
                fn(requests.length)
                    .then((value) => {
                    for (const d of requests) {
                        d.resolve(value);
                    }
                })
                    .catch((error) => {
                    for (const d of requests) {
                        d.reject(error);
                    }
                });
            }, timeout);
        });
    };
}
exports.deferAndCombine = deferAndCombine;
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.delay = delay;
function getOrAddCharacteristic(service, characteristic) {
    return (service.getCharacteristic(characteristic) ||
        service.addCharacteristic(characteristic));
}
exports.getOrAddCharacteristic = getOrAddCharacteristic;
function kelvinToMired(kelvin) {
    return 1e6 / kelvin;
}
exports.kelvinToMired = kelvinToMired;
function lookup(object, compareFn, value) {
    const compare = compareFn !== null && compareFn !== void 0 ? compareFn : ((objectProp, search) => objectProp === search);
    if (isObjectLike(object)) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i += 1) {
            if (compare(object[keys[i]], value)) {
                return keys[i];
            }
        }
    }
    return undefined;
}
exports.lookup = lookup;
function lookupCharacteristicNameByUUID(characteristic, uuid) {
    const keys = Object.keys(characteristic);
    for (let i = 0; i < keys.length; i += 1) {
        const key = keys[i];
        // @ts-ignore: not sure how to make this correct in typescript
        const c = characteristic[key];
        if ('UUID' in c && c.UUID === uuid) {
            return key;
        }
    }
    return undefined;
}
exports.lookupCharacteristicNameByUUID = lookupCharacteristicNameByUUID;
function miredToKelvin(mired) {
    return 1e6 / mired;
}
exports.miredToKelvin = miredToKelvin;
function cloneLogger(logger) {
    // @ts-ignore this doesn't work on function types
    const clonedLogger = logger.info.bind(logger);
    clonedLogger.info = logger.info;
    clonedLogger.warn = logger.warn;
    clonedLogger.error = logger.error;
    clonedLogger.debug = logger.debug;
    clonedLogger.log = logger.log;
    clonedLogger.prefix = logger.prefix;
    return clonedLogger;
}
function prefixLogger(logger, prefix) {
    const newLogger = cloneLogger(logger);
    const origLog = logger.log.bind(newLogger);
    newLogger.log = function log(level, message, ...parameters) {
        const prefixEval = prefix instanceof Function ? prefix() : prefix;
        origLog(level, `${prefixEval} ${message}`, ...parameters);
    };
    return newLogger;
}
exports.prefixLogger = prefixLogger;
//# sourceMappingURL=utils.js.map