"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const semver_1 = require("semver");
const tplink_smarthome_api_1 = require("tplink-smarthome-api");
const config_1 = require("./config");
const characteristics_1 = __importDefault(require("./characteristics"));
const settings_1 = require("./settings");
const tplink_accessory_1 = __importDefault(require("./tplink-accessory"));
const utils_1 = require("./utils");
// @ts-ignore: okay for reading json
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageConfig = require('../package.json');
class TplinkSmarthomePlatform {
    constructor(log, config, api) {
        this.log = log;
        this.api = api;
        this.Service = this.api.hap.Service;
        this.Characteristic = this.api.hap.Characteristic;
        this.homebridgeAccessories = new Map();
        this.deviceAccessories = new Map();
        this.log.info('%s v%s, node %s, homebridge v%s, api v%s', packageConfig.name, packageConfig.version, process.version, api.serverVersion, api.version);
        if (!semver_1.satisfies(process.version, packageConfig.engines.node)) {
            this.log.error('Error: not using minimum node version %s', packageConfig.engines.node);
        }
        this.log.debug('config.json: %j', config);
        this.config = config_1.parseConfig(config);
        this.log.debug('config: %j', this.config);
        this.customCharacteristics = characteristics_1.default(api.hap.Characteristic);
        const tplinkApiLogger = Object.assign(() => { }, this.log, {
            prefix: `${this.log.prefix || settings_1.PLATFORM_NAME}.API`,
        });
        const client = new tplink_smarthome_api_1.Client({
            logger: tplinkApiLogger,
            defaultSendOptions: this.config.defaultSendOptions,
        });
        client.on('device-new', (device) => {
            this.log.info(`New Device Online: ${chalk_1.default.blue(`[${device.alias}]`)} %s [%s]`, device.deviceType, device.id, device.host, device.port);
            this.foundDevice(device);
        });
        client.on('device-online', (device) => {
            this.log.debug(`Device Online: ${chalk_1.default.blue(`[${device.alias}]`)} %s [%s]`, device.deviceType, device.id, device.host, device.port);
            this.foundDevice(device);
        });
        client.on('device-offline', (device) => {
            const deviceAccessory = this.deviceAccessories.get(device.id);
            if (deviceAccessory !== undefined) {
                this.log.debug(`Device Offline: ${chalk_1.default.blue(`[${device.alias}]`)} %s [%s]`, deviceAccessory.homebridgeAccessory.displayName, device.deviceType, device.id, device.host, device.port);
            }
        });
        this.api.on("didFinishLaunching" /* DID_FINISH_LAUNCHING */, () => {
            this.log.debug("didFinishLaunching" /* DID_FINISH_LAUNCHING */);
            client.startDiscovery({
                ...this.config.discoveryOptions,
                filterCallback: (si) => {
                    return si.deviceId != null && si.deviceId.length > 0;
                },
            });
            const refreshEmeterForAccessories = async (accessories) => {
                for (const acc of accessories) {
                    const device = acc.tplinkDevice;
                    if (device.deviceType === 'plug' && device.supportsEmeter) {
                        this.log.debug(`getEmeterRealtime ${chalk_1.default.blue(`[${device.alias}]`)}`);
                        // eslint-disable-next-line no-await-in-loop
                        await device.emeter.getRealtime().catch((reason) => {
                            this.log.error('[%s] %s', device.alias, 'emeter.getRealtime()');
                            this.log.error(reason);
                        });
                    }
                }
            };
            const refreshEmeter = async () => {
                this.log.debug('refreshEmeter()');
                try {
                    const deviceAccessories = this.deviceAccessoriesByHost;
                    const promises = [];
                    for (const accForHost of deviceAccessories.values()) {
                        promises.push(refreshEmeterForAccessories(accForHost));
                    }
                    await Promise.all(promises);
                }
                catch (err) {
                    this.log.error('refreshEmeter()');
                    this.log.error(err);
                }
                finally {
                    this.log.debug('Scheduling next run of refreshEmeter() in %d(ms)', this.config.discoveryOptions.discoveryInterval);
                    setTimeout(() => {
                        refreshEmeter();
                    }, this.config.discoveryOptions.discoveryInterval);
                }
            };
            refreshEmeter();
        });
        this.api.on('shutdown', () => {
            this.log.debug('shutdown');
            client.stopDiscovery();
        });
    }
    /**
     * Return string representation of Service/Characteristic for logging
     *
     * @internal
     */
    lsc(serviceOrCharacteristic, characteristic) {
        let serviceName;
        let characteristicName;
        if (serviceOrCharacteristic instanceof this.api.hap.Service) {
            serviceName = this.getServiceName(serviceOrCharacteristic);
        }
        else if (serviceOrCharacteristic instanceof this.api.hap.Characteristic ||
            ('UUID' in serviceOrCharacteristic &&
                typeof serviceOrCharacteristic.UUID === 'string')) {
            characteristicName = this.getCharacteristicName(serviceOrCharacteristic);
        }
        if (characteristic instanceof this.api.hap.Characteristic) {
            characteristicName = this.getCharacteristicName(characteristic);
        }
        if (serviceName != null && characteristicName != null) {
            return `[${chalk_1.default.yellow(serviceName)}.${chalk_1.default.green(characteristicName)}]`;
        }
        if (serviceName !== undefined)
            return `[${chalk_1.default.yellow(serviceName)}]`;
        return `[${chalk_1.default.green(characteristicName)}]`;
    }
    get deviceAccessoriesByHost() {
        const byHost = new Map();
        for (const [, tpLinkAccessory] of this.deviceAccessories) {
            const { host } = tpLinkAccessory.tplinkDevice;
            const arr = byHost.get(host);
            if (arr != null) {
                arr.push(tpLinkAccessory);
            }
            else {
                byHost.set(host, [tpLinkAccessory]);
            }
        }
        return byHost;
    }
    createTplinkAccessory(accessory, tplinkDevice) {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const { config, Service } = this;
        const [category, services] = (() => {
            if (tplinkDevice.deviceType === 'bulb') {
                return [5 /* LIGHTBULB */, [Service.Lightbulb]];
            }
            // plug
            if (config.switchModels &&
                config.switchModels.findIndex((m) => tplinkDevice.model.includes(m)) !==
                    -1) {
                return [8 /* SWITCH */, [Service.Switch]];
            }
            if (tplinkDevice.supportsDimmer) {
                return [5 /* LIGHTBULB */, [Service.Lightbulb]];
            }
            return [7 /* OUTLET */, [Service.Outlet]];
        })();
        return new tplink_accessory_1.default(this, this.config, accessory, tplinkDevice, category, services);
    }
    getCategoryName(category) {
        // @ts-ignore: this should work
        // eslint-disable-next-line deprecation/deprecation
        return this.api.hap.Accessory.Categories[category];
    }
    getServiceName(service) {
        return utils_1.lookup(this.api.hap.Service, (thisKeyValue, value) => utils_1.isObjectLike(thisKeyValue) &&
            'UUID' in thisKeyValue &&
            thisKeyValue.UUID === value, service.UUID);
    }
    getCharacteristicName(characteristic) {
        if ('name' in characteristic && characteristic.name !== undefined)
            return characteristic.name;
        if ('displayName' in characteristic &&
            characteristic.displayName !== undefined)
            return characteristic.displayName;
        if ('UUID' in characteristic) {
            return utils_1.lookupCharacteristicNameByUUID(this.api.hap.Characteristic, characteristic.UUID);
        }
        return undefined;
    }
    /**
     * Registers a Homebridge PlatformAccessory.
     *
     * Calls {@link external:homebridge.API#registerPlatformAccessories}
     */
    registerPlatformAccessory(platformAccessory) {
        this.log.debug(`registerPlatformAccessory(${chalk_1.default.blue(`[${platformAccessory.displayName}]`)})`);
        this.api.registerPlatformAccessories(settings_1.PLUGIN_NAME, settings_1.PLATFORM_NAME, [
            platformAccessory,
        ]);
    }
    /**
     * Function invoked when homebridge tries to restore cached accessory
     */
    configureAccessory(accessory) {
        var _a;
        this.log.info(`Configuring cached accessory: ${chalk_1.default.blue(`[${accessory.displayName}]`)} UUID: ${accessory.UUID} deviceId: %s `, (_a = accessory.context) === null || _a === void 0 ? void 0 : _a.deviceId);
        this.log.debug('%O', accessory.context);
        this.homebridgeAccessories.set(accessory.UUID, accessory);
    }
    /**
     * Adds a new or existing real device.
     */
    foundDevice(device) {
        // TODO: refactor this function
        const deviceId = device.id;
        if (deviceId == null || deviceId.length === 0) {
            this.log.error('Missing deviceId: %s', device.host);
            return;
        }
        let deviceAccessory = this.deviceAccessories.get(deviceId);
        if (deviceAccessory !== undefined) {
            return;
        }
        this.log.info(`Adding: ${chalk_1.default.blue(`[${device.alias}]`)} %s [%s]`, device.deviceType, deviceId);
        const uuid = this.api.hap.uuid.generate(deviceId);
        const homebridgeAccessory = this.homebridgeAccessories.get(uuid);
        deviceAccessory = this.createTplinkAccessory(homebridgeAccessory, device);
        this.deviceAccessories.set(deviceId, deviceAccessory);
        this.homebridgeAccessories.set(uuid, deviceAccessory.homebridgeAccessory);
    }
    /**
     * Removes an accessory and unregisters it from Homebridge
     */
    // @ts-ignore: future use
    removeAccessory(homebridgeAccessory) {
        this.log.info(`Removing: ${chalk_1.default.blue(`[${homebridgeAccessory.displayName}]`)}`);
        this.deviceAccessories.delete(homebridgeAccessory.context.deviceId);
        this.homebridgeAccessories.delete(homebridgeAccessory.UUID);
        this.api.unregisterPlatformAccessories(settings_1.PLUGIN_NAME, settings_1.PLATFORM_NAME, [
            homebridgeAccessory,
        ]);
    }
}
exports.default = TplinkSmarthomePlatform;
//# sourceMappingURL=platform.js.map